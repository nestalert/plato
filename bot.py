import json
import random
import os
import requests
from appointments import DatabaseManager,AppointmentHandler
from professor import ProfessorHandler
from transformer_engine import NLPProcessor

class IntentChatbot:
    def __init__(self, uname, pwd, class_suggestions, assignments,
                 intents_file='intents.json', links_file='links.json', professors_file='professors.json'):
        
        self.intents_file = intents_file
        self.links_file = links_file
        self.class_suggestions = class_suggestions
        self.assignments = assignments
        self.uname = uname
        self.pwd = pwd
        
        self.intents = None
        self.links = None
        self.load_json()
        
        self.db_manager = DatabaseManager()
        self.professor_handler = ProfessorHandler(professors_file)
        self.nlp_processor = NLPProcessor(self.intents)
        self.appointment_handler = AppointmentHandler(self.db_manager, uname)
        
        self.load_or_train_model()
        
    def load_json(self):
        with open(self.intents_file, 'r', encoding='utf-8') as f:
            self.intents = json.load(f)
                
        with open(self.links_file, 'r', encoding='utf-8') as f:
            self.links = json.load(f)

    def load_or_train_model(self):
        intents_mtime_saved = self.nlp_processor.load_model()
        
        if intents_mtime_saved is not None:
            current_intents_mtime = os.path.getmtime(self.intents_file)
            
            if current_intents_mtime == intents_mtime_saved:
                print(f"Loaded model from {self.nlp_processor.model_file}. Intents file hasn't changed.")
                self.nlp_processor.load_feedback()
                self.nlp_processor.update_feedback_vectors()
                return
            else:
                print("Intents file has been modified. Re-training model.")
                self.nlp_processor.train()
                self.nlp_processor.save_model(current_intents_mtime)
        else:
            print("Saved model not found. Training model.")
            self.nlp_processor.train()
            current_intents_mtime = os.path.getmtime(self.intents_file)
            self.nlp_processor.save_model(current_intents_mtime)
        
        self.nlp_processor.load_feedback()
    
    def query_local_llm(self, user_input):
        url = "http://localhost:11434/api/generate"
        knowledge_base = [
            {"tag": i['tag'], "examples": i['patterns'][:2]} 
            for i in self.intents
        ]
        
        system_prompt = (
            "You are a University Chatbot for the University of West Attica. Below is a list of topics (intents) you are officially trained to handle. "
            f"Official Knowledge Base: {json.dumps(knowledge_base)}\n\n"
            "If the user's question relates to these topics, guide them or answer based on the intent. "
            "If it is outside these topics, answer politely but remind them you are a university assistant."
        )

        data = {
            "model": "Gemma3:1b",
            "prompt": f"{system_prompt}\nUser: {user_input}\nAssistant:",
            "stream": False
        }
            
        try:
            response = requests.post(url, json=data)
            response.raise_for_status()
            return response.json()['response']
        except Exception as e:
            print(f"Local LLM Error: {e}")
            return None

    def get_response(self, user_input, confidence_threshold=0.45, ask_feedback=True):
        if self.appointment_handler.is_active():
            response = self.appointment_handler.handle_flow(user_input)
            return response, "appointment_flow"
        
        if user_input.lower() == "create appointment":
            return self.appointment_handler.start_create(), "appointment_flow"

        if user_input.lower() == "delete appointment":
            return self.appointment_handler.start_delete(), "appointment_flow"

        predicted_tag, confidence = self.nlp_processor.predict_intent(user_input)
        
        print(f"<<Prediction='{predicted_tag}', Conf={confidence:.2f}>>")
        
        if predicted_tag == "teacher" or confidence < confidence_threshold: # I had the professor code run all the time, but I don't want it
            professor = self.professor_handler.detect_professor(user_input) # Triggering all the time. Maybe someone searches something
            if professor: # irrelevant that has a professor name on it.
                return self.professor_handler.format_professor_info(professor), None
            
        if confidence < confidence_threshold:
            llm_text = self.query_local_llm(user_input)
            if llm_text:
                final_response = (
                    f"{llm_text}\n\n"
                    "[Disclaimer: Generated by AI. Information may be inaccurate or offensive.]"
                )
                return final_response, "llm_fallback"
            else:
                predicted_tag = "fallback"
        
        intent = self.nlp_processor.tag_to_intent[predicted_tag]
        response = random.choice(intent['responses'])

        if predicted_tag == "class_selection" and self.class_suggestions:
            response = self.format_class_suggestions()
        
        if predicted_tag == "assignment":
            response = self.format_assignments()

        if predicted_tag == "appointment":
            response = self.format_appointments()

        return response, (predicted_tag if ask_feedback else None)

    def format_class_suggestions(self):
        output = "Based on your record, we recommend the following classes:\n"
        for i, course in enumerate(self.class_suggestions, start=1):
            output += f"{i}. {course}\n"
        output += "You can also check the Schedule at any time: [[Schedule]]"
        return output
    
    def format_assignments(self):
        output = "Checking your assignments now...\n"
        if not self.assignments:
            output += "You have no assignments. Good for you!"
        else:
            for i, assignment in enumerate(self.assignments, start=1):
                output += (
                    f"{i}. {assignment['due_status']} ({assignment['end_date']}): "
                    f"{assignment['name']}. {assignment['description']}. IN: "
                    f"{assignment['course_name']}\n"
                )
        return output

    def format_appointments(self):
        output = self.appointment_handler.read_appointments()
        output += "\nIf you wish to add an appointment, type 'create appointment'."
        output += "\nIf you wish to delete an appointment, type 'delete appointment'."
        return output

    def replace_links(self, response):
        for placeholder, link_value in self.links.items():
            response = response.replace(placeholder, link_value)
        return response
    
    def get_available_intents(self):
        intents_list = []
        for intent in self.intents:
            tag = intent['tag']
            if tag == "fallback":
                continue
            example = intent['patterns'][0] if intent['patterns'] else 'N/A'
            intents_list.append(f"{tag}: {example}")
        return intents_list

    def handle_feedback(self, last_user_input, correct_tag=None):
        print("\nWhat should the correct intent be?")
        print("Available intents:")
        for i, intent_info in enumerate(self.get_available_intents(), 1):
            print(f"  {i}. {intent_info}")
        
        correct_tag = input("\nEnter correct intent tag: ").strip()
        
        if correct_tag in self.nlp_processor.tag_to_intent:
            self.nlp_processor.add_feedback(last_user_input, correct_tag)
            print("Bot: Thank you! I'll remember that.\n")
        else:
            print("Bot: Invalid intent tag. Feedback not recorded.\n")